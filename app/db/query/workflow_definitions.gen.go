// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"seraph/app/db/models"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newWorkflowDefinition(db *gorm.DB) workflowDefinition {
	_workflowDefinition := workflowDefinition{}

	_workflowDefinition.workflowDefinitionDo.UseDB(db)
	_workflowDefinition.workflowDefinitionDo.UseModel(&models.WorkflowDefinition{})

	tableName := _workflowDefinition.workflowDefinitionDo.TableName()
	_workflowDefinition.ALL = field.NewField(tableName, "*")
	_workflowDefinition.ID = field.NewString(tableName, "id")
	_workflowDefinition.Name = field.NewString(tableName, "name")
	_workflowDefinition.Description = field.NewString(tableName, "description")
	_workflowDefinition.Definition = field.NewString(tableName, "definition")
	_workflowDefinition.Tags = field.NewField(tableName, "tags")
	_workflowDefinition.Spec = field.NewString(tableName, "spec")
	_workflowDefinition.Scope = field.NewString(tableName, "scope")
	_workflowDefinition.ProjectID = field.NewString(tableName, "project_id")
	_workflowDefinition.CreatedAt = field.NewTime(tableName, "created_at")
	_workflowDefinition.UpdatedAt = field.NewTime(tableName, "updated_at")
	_workflowDefinition.Deleted = field.NewInt(tableName, "deleted")
	_workflowDefinition.DeletedAt = field.NewTime(tableName, "deleted_at")
	_workflowDefinition.Namespace = field.NewString(tableName, "namespace")

	_workflowDefinition.fillFieldMap()

	return _workflowDefinition
}

type workflowDefinition struct {
	workflowDefinitionDo workflowDefinitionDo

	ALL         field.Field
	ID          field.String
	Name        field.String
	Description field.String
	Definition  field.String
	Tags        field.Field
	Spec        field.String
	Scope       field.String
	ProjectID   field.String
	CreatedAt   field.Time
	UpdatedAt   field.Time
	Deleted     field.Int
	DeletedAt   field.Time
	Namespace   field.String

	fieldMap map[string]field.Expr
}

func (w workflowDefinition) As(alias string) *workflowDefinition {
	w.workflowDefinitionDo.DO = *(w.workflowDefinitionDo.As(alias).(*gen.DO))

	w.ALL = field.NewField(alias, "*")
	w.ID = field.NewString(alias, "id")
	w.Name = field.NewString(alias, "name")
	w.Description = field.NewString(alias, "description")
	w.Definition = field.NewString(alias, "definition")
	w.Tags = field.NewField(alias, "tags")
	w.Spec = field.NewString(alias, "spec")
	w.Scope = field.NewString(alias, "scope")
	w.ProjectID = field.NewString(alias, "project_id")
	w.CreatedAt = field.NewTime(alias, "created_at")
	w.UpdatedAt = field.NewTime(alias, "updated_at")
	w.Deleted = field.NewInt(alias, "deleted")
	w.DeletedAt = field.NewTime(alias, "deleted_at")
	w.Namespace = field.NewString(alias, "namespace")

	w.fillFieldMap()

	return &w
}

func (w *workflowDefinition) WithContext(ctx context.Context) *workflowDefinitionDo {
	return w.workflowDefinitionDo.WithContext(ctx)
}

func (w workflowDefinition) TableName() string { return w.workflowDefinitionDo.TableName() }

func (w *workflowDefinition) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	return _f.(field.OrderExpr), ok
}

func (w *workflowDefinition) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 13)
	w.fieldMap["id"] = w.ID
	w.fieldMap["name"] = w.Name
	w.fieldMap["description"] = w.Description
	w.fieldMap["definition"] = w.Definition
	w.fieldMap["tags"] = w.Tags
	w.fieldMap["spec"] = w.Spec
	w.fieldMap["scope"] = w.Scope
	w.fieldMap["project_id"] = w.ProjectID
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
	w.fieldMap["deleted"] = w.Deleted
	w.fieldMap["deleted_at"] = w.DeletedAt
	w.fieldMap["namespace"] = w.Namespace
}

func (w workflowDefinition) clone(db *gorm.DB) workflowDefinition {
	w.workflowDefinitionDo.ReplaceDB(db)
	return w
}

type workflowDefinitionDo struct{ gen.DO }

func (w workflowDefinitionDo) Debug() *workflowDefinitionDo {
	return w.withDO(w.DO.Debug())
}

func (w workflowDefinitionDo) WithContext(ctx context.Context) *workflowDefinitionDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w workflowDefinitionDo) Clauses(conds ...clause.Expression) *workflowDefinitionDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w workflowDefinitionDo) Not(conds ...gen.Condition) *workflowDefinitionDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w workflowDefinitionDo) Or(conds ...gen.Condition) *workflowDefinitionDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w workflowDefinitionDo) Select(conds ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w workflowDefinitionDo) Where(conds ...gen.Condition) *workflowDefinitionDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w workflowDefinitionDo) Order(conds ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w workflowDefinitionDo) Distinct(cols ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w workflowDefinitionDo) Omit(cols ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w workflowDefinitionDo) Join(table schema.Tabler, on ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w workflowDefinitionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w workflowDefinitionDo) RightJoin(table schema.Tabler, on ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w workflowDefinitionDo) Group(cols ...field.Expr) *workflowDefinitionDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w workflowDefinitionDo) Having(conds ...gen.Condition) *workflowDefinitionDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w workflowDefinitionDo) Limit(limit int) *workflowDefinitionDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w workflowDefinitionDo) Offset(offset int) *workflowDefinitionDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w workflowDefinitionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *workflowDefinitionDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w workflowDefinitionDo) Unscoped() *workflowDefinitionDo {
	return w.withDO(w.DO.Unscoped())
}

func (w workflowDefinitionDo) Create(values ...*models.WorkflowDefinition) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w workflowDefinitionDo) CreateInBatches(values []*models.WorkflowDefinition, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w workflowDefinitionDo) Save(values ...*models.WorkflowDefinition) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w workflowDefinitionDo) First() (*models.WorkflowDefinition, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowDefinition), nil
	}
}

func (w workflowDefinitionDo) Take() (*models.WorkflowDefinition, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowDefinition), nil
	}
}

func (w workflowDefinitionDo) Last() (*models.WorkflowDefinition, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowDefinition), nil
	}
}

func (w workflowDefinitionDo) Find() ([]*models.WorkflowDefinition, error) {
	result, err := w.DO.Find()
	return result.([]*models.WorkflowDefinition), err
}

func (w workflowDefinitionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.WorkflowDefinition, err error) {
	buf := make([]*models.WorkflowDefinition, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w workflowDefinitionDo) FindInBatches(result *[]*models.WorkflowDefinition, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w workflowDefinitionDo) Attrs(attrs ...field.AssignExpr) *workflowDefinitionDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w workflowDefinitionDo) Assign(attrs ...field.AssignExpr) *workflowDefinitionDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w workflowDefinitionDo) Joins(field field.RelationField) *workflowDefinitionDo {
	return w.withDO(w.DO.Joins(field))
}

func (w workflowDefinitionDo) Preload(field field.RelationField) *workflowDefinitionDo {
	return w.withDO(w.DO.Preload(field))
}

func (w workflowDefinitionDo) FirstOrInit() (*models.WorkflowDefinition, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowDefinition), nil
	}
}

func (w workflowDefinitionDo) FirstOrCreate() (*models.WorkflowDefinition, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowDefinition), nil
	}
}

func (w workflowDefinitionDo) FindByPage(offset int, limit int) (result []*models.WorkflowDefinition, count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	result, err = w.Offset(offset).Limit(limit).Find()
	return
}

func (w workflowDefinitionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w *workflowDefinitionDo) withDO(do gen.Dao) *workflowDefinitionDo {
	w.DO = *do.(*gen.DO)
	return w
}
