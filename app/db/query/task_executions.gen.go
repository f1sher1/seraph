// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"seraph/app/db/models"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newTaskExecution(db *gorm.DB) taskExecution {
	_taskExecution := taskExecution{}

	_taskExecution.taskExecutionDo.UseDB(db)
	_taskExecution.taskExecutionDo.UseModel(&models.TaskExecution{})

	tableName := _taskExecution.taskExecutionDo.TableName()
	_taskExecution.ALL = field.NewField(tableName, "*")
	_taskExecution.ID = field.NewString(tableName, "id")
	_taskExecution.Name = field.NewString(tableName, "name")
	_taskExecution.Description = field.NewString(tableName, "description")
	_taskExecution.Tags = field.NewField(tableName, "tags")
	_taskExecution.WorkflowID = field.NewString(tableName, "workflow_id")
	_taskExecution.ProjectID = field.NewString(tableName, "project_id")
	_taskExecution.State = field.NewString(tableName, "state")
	_taskExecution.StateInfo = field.NewString(tableName, "state_info")
	_taskExecution.CreatedAt = field.NewTime(tableName, "created_at")
	_taskExecution.UpdatedAt = field.NewTime(tableName, "updated_at")
	_taskExecution.Deleted = field.NewInt(tableName, "deleted")
	_taskExecution.DeletedAt = field.NewTime(tableName, "deleted_at")
	_taskExecution.WorkflowNamespace = field.NewString(tableName, "workflow_namespace")
	_taskExecution.Scope = field.NewString(tableName, "scope")
	_taskExecution.StartedAt = field.NewTime(tableName, "started_at")
	_taskExecution.FinishedAt = field.NewTime(tableName, "finished_at")
	_taskExecution.RootExecutionID = field.NewString(tableName, "root_execution_id")
	_taskExecution.WorkflowExecutionID = field.NewString(tableName, "workflow_execution_id")
	_taskExecution.Spec = field.NewString(tableName, "spec")
	_taskExecution.Published = field.NewField(tableName, "published")
	_taskExecution.Type = field.NewString(tableName, "type")
	_taskExecution.Processed = field.NewBool(tableName, "processed")
	_taskExecution.NextTasks = field.NewField(tableName, "next_tasks")
	_taskExecution.HasNextTasks = field.NewBool(tableName, "has_next_tasks")
	_taskExecution.ErrorHandled = field.NewBool(tableName, "error_handled")
	_taskExecution.UniqueKey = field.NewString(tableName, "unique_key")
	_taskExecution.RuntimeContext = field.NewField(tableName, "runtime_context")
	_taskExecution.InContext = field.NewField(tableName, "in_context")
	_taskExecution.WorkflowName = field.NewString(tableName, "workflow_name")

	_taskExecution.fillFieldMap()

	return _taskExecution
}

type taskExecution struct {
	taskExecutionDo taskExecutionDo

	ALL                 field.Field
	ID                  field.String
	Name                field.String
	Description         field.String
	Tags                field.Field
	WorkflowID          field.String
	ProjectID           field.String
	State               field.String
	StateInfo           field.String
	CreatedAt           field.Time
	UpdatedAt           field.Time
	Deleted             field.Int
	DeletedAt           field.Time
	WorkflowNamespace   field.String
	Scope               field.String
	StartedAt           field.Time
	FinishedAt          field.Time
	RootExecutionID     field.String
	WorkflowExecutionID field.String
	Spec                field.String
	Published           field.Field
	Type                field.String
	Processed           field.Bool
	NextTasks           field.Field
	HasNextTasks        field.Bool
	ErrorHandled        field.Bool
	UniqueKey           field.String
	RuntimeContext      field.Field
	InContext           field.Field
	WorkflowName        field.String

	fieldMap map[string]field.Expr
}

func (t taskExecution) As(alias string) *taskExecution {
	t.taskExecutionDo.DO = *(t.taskExecutionDo.As(alias).(*gen.DO))

	t.ALL = field.NewField(alias, "*")
	t.ID = field.NewString(alias, "id")
	t.Name = field.NewString(alias, "name")
	t.Description = field.NewString(alias, "description")
	t.Tags = field.NewField(alias, "tags")
	t.WorkflowID = field.NewString(alias, "workflow_id")
	t.ProjectID = field.NewString(alias, "project_id")
	t.State = field.NewString(alias, "state")
	t.StateInfo = field.NewString(alias, "state_info")
	t.CreatedAt = field.NewTime(alias, "created_at")
	t.UpdatedAt = field.NewTime(alias, "updated_at")
	t.Deleted = field.NewInt(alias, "deleted")
	t.DeletedAt = field.NewTime(alias, "deleted_at")
	t.WorkflowNamespace = field.NewString(alias, "workflow_namespace")
	t.Scope = field.NewString(alias, "scope")
	t.StartedAt = field.NewTime(alias, "started_at")
	t.FinishedAt = field.NewTime(alias, "finished_at")
	t.RootExecutionID = field.NewString(alias, "root_execution_id")
	t.WorkflowExecutionID = field.NewString(alias, "workflow_execution_id")
	t.Spec = field.NewString(alias, "spec")
	t.Published = field.NewField(alias, "published")
	t.Type = field.NewString(alias, "type")
	t.Processed = field.NewBool(alias, "processed")
	t.NextTasks = field.NewField(alias, "next_tasks")
	t.HasNextTasks = field.NewBool(alias, "has_next_tasks")
	t.ErrorHandled = field.NewBool(alias, "error_handled")
	t.UniqueKey = field.NewString(alias, "unique_key")
	t.RuntimeContext = field.NewField(alias, "runtime_context")
	t.InContext = field.NewField(alias, "in_context")
	t.WorkflowName = field.NewString(alias, "workflow_name")

	t.fillFieldMap()

	return &t
}

func (t *taskExecution) WithContext(ctx context.Context) *taskExecutionDo {
	return t.taskExecutionDo.WithContext(ctx)
}

func (t taskExecution) TableName() string { return t.taskExecutionDo.TableName() }

func (t *taskExecution) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	return _f.(field.OrderExpr), ok
}

func (t *taskExecution) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 29)
	t.fieldMap["id"] = t.ID
	t.fieldMap["name"] = t.Name
	t.fieldMap["description"] = t.Description
	t.fieldMap["tags"] = t.Tags
	t.fieldMap["workflow_id"] = t.WorkflowID
	t.fieldMap["project_id"] = t.ProjectID
	t.fieldMap["state"] = t.State
	t.fieldMap["state_info"] = t.StateInfo
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["deleted"] = t.Deleted
	t.fieldMap["deleted_at"] = t.DeletedAt
	t.fieldMap["workflow_namespace"] = t.WorkflowNamespace
	t.fieldMap["scope"] = t.Scope
	t.fieldMap["started_at"] = t.StartedAt
	t.fieldMap["finished_at"] = t.FinishedAt
	t.fieldMap["root_execution_id"] = t.RootExecutionID
	t.fieldMap["workflow_execution_id"] = t.WorkflowExecutionID
	t.fieldMap["spec"] = t.Spec
	t.fieldMap["published"] = t.Published
	t.fieldMap["type"] = t.Type
	t.fieldMap["processed"] = t.Processed
	t.fieldMap["next_tasks"] = t.NextTasks
	t.fieldMap["has_next_tasks"] = t.HasNextTasks
	t.fieldMap["error_handled"] = t.ErrorHandled
	t.fieldMap["unique_key"] = t.UniqueKey
	t.fieldMap["runtime_context"] = t.RuntimeContext
	t.fieldMap["in_context"] = t.InContext
	t.fieldMap["workflow_name"] = t.WorkflowName
}

func (t taskExecution) clone(db *gorm.DB) taskExecution {
	t.taskExecutionDo.ReplaceDB(db)
	return t
}

type taskExecutionDo struct{ gen.DO }

func (t taskExecutionDo) Debug() *taskExecutionDo {
	return t.withDO(t.DO.Debug())
}

func (t taskExecutionDo) WithContext(ctx context.Context) *taskExecutionDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t taskExecutionDo) Clauses(conds ...clause.Expression) *taskExecutionDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t taskExecutionDo) Not(conds ...gen.Condition) *taskExecutionDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t taskExecutionDo) Or(conds ...gen.Condition) *taskExecutionDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t taskExecutionDo) Select(conds ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t taskExecutionDo) Where(conds ...gen.Condition) *taskExecutionDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t taskExecutionDo) Order(conds ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t taskExecutionDo) Distinct(cols ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t taskExecutionDo) Omit(cols ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t taskExecutionDo) Join(table schema.Tabler, on ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t taskExecutionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t taskExecutionDo) RightJoin(table schema.Tabler, on ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t taskExecutionDo) Group(cols ...field.Expr) *taskExecutionDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t taskExecutionDo) Having(conds ...gen.Condition) *taskExecutionDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t taskExecutionDo) Limit(limit int) *taskExecutionDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t taskExecutionDo) Offset(offset int) *taskExecutionDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t taskExecutionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *taskExecutionDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t taskExecutionDo) Unscoped() *taskExecutionDo {
	return t.withDO(t.DO.Unscoped())
}

func (t taskExecutionDo) Create(values ...*models.TaskExecution) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t taskExecutionDo) CreateInBatches(values []*models.TaskExecution, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t taskExecutionDo) Save(values ...*models.TaskExecution) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t taskExecutionDo) First() (*models.TaskExecution, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.TaskExecution), nil
	}
}

func (t taskExecutionDo) Take() (*models.TaskExecution, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.TaskExecution), nil
	}
}

func (t taskExecutionDo) Last() (*models.TaskExecution, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.TaskExecution), nil
	}
}

func (t taskExecutionDo) Find() ([]*models.TaskExecution, error) {
	result, err := t.DO.Find()
	return result.([]*models.TaskExecution), err
}

func (t taskExecutionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.TaskExecution, err error) {
	buf := make([]*models.TaskExecution, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t taskExecutionDo) FindInBatches(result *[]*models.TaskExecution, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t taskExecutionDo) Attrs(attrs ...field.AssignExpr) *taskExecutionDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t taskExecutionDo) Assign(attrs ...field.AssignExpr) *taskExecutionDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t taskExecutionDo) Joins(field field.RelationField) *taskExecutionDo {
	return t.withDO(t.DO.Joins(field))
}

func (t taskExecutionDo) Preload(field field.RelationField) *taskExecutionDo {
	return t.withDO(t.DO.Preload(field))
}

func (t taskExecutionDo) FirstOrInit() (*models.TaskExecution, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.TaskExecution), nil
	}
}

func (t taskExecutionDo) FirstOrCreate() (*models.TaskExecution, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.TaskExecution), nil
	}
}

func (t taskExecutionDo) FindByPage(offset int, limit int) (result []*models.TaskExecution, count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	result, err = t.Offset(offset).Limit(limit).Find()
	return
}

func (t taskExecutionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t *taskExecutionDo) withDO(do gen.Dao) *taskExecutionDo {
	t.DO = *do.(*gen.DO)
	return t
}
