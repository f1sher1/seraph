// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"seraph/app/db/models"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newWorkflowExecution(db *gorm.DB) workflowExecution {
	_workflowExecution := workflowExecution{}

	_workflowExecution.workflowExecutionDo.UseDB(db)
	_workflowExecution.workflowExecutionDo.UseModel(&models.WorkflowExecution{})

	tableName := _workflowExecution.workflowExecutionDo.TableName()
	_workflowExecution.ALL = field.NewField(tableName, "*")
	_workflowExecution.ID = field.NewString(tableName, "id")
	_workflowExecution.Name = field.NewString(tableName, "name")
	_workflowExecution.Description = field.NewString(tableName, "description")
	_workflowExecution.Tags = field.NewField(tableName, "tags")
	_workflowExecution.WorkflowID = field.NewString(tableName, "workflow_id")
	_workflowExecution.ProjectID = field.NewString(tableName, "project_id")
	_workflowExecution.State = field.NewString(tableName, "state")
	_workflowExecution.StateInfo = field.NewString(tableName, "state_info")
	_workflowExecution.CreatedAt = field.NewTime(tableName, "created_at")
	_workflowExecution.UpdatedAt = field.NewTime(tableName, "updated_at")
	_workflowExecution.Deleted = field.NewInt(tableName, "deleted")
	_workflowExecution.DeletedAt = field.NewTime(tableName, "deleted_at")
	_workflowExecution.WorkflowNamespace = field.NewString(tableName, "workflow_namespace")
	_workflowExecution.Scope = field.NewString(tableName, "scope")
	_workflowExecution.StartedAt = field.NewTime(tableName, "started_at")
	_workflowExecution.FinishedAt = field.NewTime(tableName, "finished_at")
	_workflowExecution.RootExecutionID = field.NewString(tableName, "root_execution_id")
	_workflowExecution.Spec = field.NewString(tableName, "spec")
	_workflowExecution.Input = field.NewField(tableName, "input")
	_workflowExecution.Output = field.NewField(tableName, "output")
	_workflowExecution.Params = field.NewField(tableName, "params")
	_workflowExecution.RuntimeContext = field.NewField(tableName, "runtime_context")
	_workflowExecution.Context = field.NewField(tableName, "context")
	_workflowExecution.WorkflowName = field.NewString(tableName, "workflow_name")
	_workflowExecution.TaskExecutionID = field.NewString(tableName, "task_execution_id")

	_workflowExecution.fillFieldMap()

	return _workflowExecution
}

type workflowExecution struct {
	workflowExecutionDo workflowExecutionDo

	ALL               field.Field
	ID                field.String
	Name              field.String
	Description       field.String
	Tags              field.Field
	WorkflowID        field.String
	ProjectID         field.String
	State             field.String
	StateInfo         field.String
	CreatedAt         field.Time
	UpdatedAt         field.Time
	Deleted           field.Int
	DeletedAt         field.Time
	WorkflowNamespace field.String
	Scope             field.String
	StartedAt         field.Time
	FinishedAt        field.Time
	RootExecutionID   field.String
	Spec              field.String
	Input             field.Field
	Output            field.Field
	Params            field.Field
	RuntimeContext    field.Field
	Context           field.Field
	WorkflowName      field.String
	TaskExecutionID   field.String

	fieldMap map[string]field.Expr
}

func (w workflowExecution) As(alias string) *workflowExecution {
	w.workflowExecutionDo.DO = *(w.workflowExecutionDo.As(alias).(*gen.DO))

	w.ALL = field.NewField(alias, "*")
	w.ID = field.NewString(alias, "id")
	w.Name = field.NewString(alias, "name")
	w.Description = field.NewString(alias, "description")
	w.Tags = field.NewField(alias, "tags")
	w.WorkflowID = field.NewString(alias, "workflow_id")
	w.ProjectID = field.NewString(alias, "project_id")
	w.State = field.NewString(alias, "state")
	w.StateInfo = field.NewString(alias, "state_info")
	w.CreatedAt = field.NewTime(alias, "created_at")
	w.UpdatedAt = field.NewTime(alias, "updated_at")
	w.Deleted = field.NewInt(alias, "deleted")
	w.DeletedAt = field.NewTime(alias, "deleted_at")
	w.WorkflowNamespace = field.NewString(alias, "workflow_namespace")
	w.Scope = field.NewString(alias, "scope")
	w.StartedAt = field.NewTime(alias, "started_at")
	w.FinishedAt = field.NewTime(alias, "finished_at")
	w.RootExecutionID = field.NewString(alias, "root_execution_id")
	w.Spec = field.NewString(alias, "spec")
	w.Input = field.NewField(alias, "input")
	w.Output = field.NewField(alias, "output")
	w.Params = field.NewField(alias, "params")
	w.RuntimeContext = field.NewField(alias, "runtime_context")
	w.Context = field.NewField(alias, "context")
	w.WorkflowName = field.NewString(alias, "workflow_name")
	w.TaskExecutionID = field.NewString(alias, "task_execution_id")

	w.fillFieldMap()

	return &w
}

func (w *workflowExecution) WithContext(ctx context.Context) *workflowExecutionDo {
	return w.workflowExecutionDo.WithContext(ctx)
}

func (w workflowExecution) TableName() string { return w.workflowExecutionDo.TableName() }

func (w *workflowExecution) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	return _f.(field.OrderExpr), ok
}

func (w *workflowExecution) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 25)
	w.fieldMap["id"] = w.ID
	w.fieldMap["name"] = w.Name
	w.fieldMap["description"] = w.Description
	w.fieldMap["tags"] = w.Tags
	w.fieldMap["workflow_id"] = w.WorkflowID
	w.fieldMap["project_id"] = w.ProjectID
	w.fieldMap["state"] = w.State
	w.fieldMap["state_info"] = w.StateInfo
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
	w.fieldMap["deleted"] = w.Deleted
	w.fieldMap["deleted_at"] = w.DeletedAt
	w.fieldMap["workflow_namespace"] = w.WorkflowNamespace
	w.fieldMap["scope"] = w.Scope
	w.fieldMap["started_at"] = w.StartedAt
	w.fieldMap["finished_at"] = w.FinishedAt
	w.fieldMap["root_execution_id"] = w.RootExecutionID
	w.fieldMap["spec"] = w.Spec
	w.fieldMap["input"] = w.Input
	w.fieldMap["output"] = w.Output
	w.fieldMap["params"] = w.Params
	w.fieldMap["runtime_context"] = w.RuntimeContext
	w.fieldMap["context"] = w.Context
	w.fieldMap["workflow_name"] = w.WorkflowName
	w.fieldMap["task_execution_id"] = w.TaskExecutionID
}

func (w workflowExecution) clone(db *gorm.DB) workflowExecution {
	w.workflowExecutionDo.ReplaceDB(db)
	return w
}

type workflowExecutionDo struct{ gen.DO }

func (w workflowExecutionDo) Debug() *workflowExecutionDo {
	return w.withDO(w.DO.Debug())
}

func (w workflowExecutionDo) WithContext(ctx context.Context) *workflowExecutionDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w workflowExecutionDo) Clauses(conds ...clause.Expression) *workflowExecutionDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w workflowExecutionDo) Not(conds ...gen.Condition) *workflowExecutionDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w workflowExecutionDo) Or(conds ...gen.Condition) *workflowExecutionDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w workflowExecutionDo) Select(conds ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w workflowExecutionDo) Where(conds ...gen.Condition) *workflowExecutionDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w workflowExecutionDo) Order(conds ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w workflowExecutionDo) Distinct(cols ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w workflowExecutionDo) Omit(cols ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w workflowExecutionDo) Join(table schema.Tabler, on ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w workflowExecutionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w workflowExecutionDo) RightJoin(table schema.Tabler, on ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w workflowExecutionDo) Group(cols ...field.Expr) *workflowExecutionDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w workflowExecutionDo) Having(conds ...gen.Condition) *workflowExecutionDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w workflowExecutionDo) Limit(limit int) *workflowExecutionDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w workflowExecutionDo) Offset(offset int) *workflowExecutionDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w workflowExecutionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *workflowExecutionDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w workflowExecutionDo) Unscoped() *workflowExecutionDo {
	return w.withDO(w.DO.Unscoped())
}

func (w workflowExecutionDo) Create(values ...*models.WorkflowExecution) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w workflowExecutionDo) CreateInBatches(values []*models.WorkflowExecution, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w workflowExecutionDo) Save(values ...*models.WorkflowExecution) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w workflowExecutionDo) First() (*models.WorkflowExecution, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowExecution), nil
	}
}

func (w workflowExecutionDo) Take() (*models.WorkflowExecution, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowExecution), nil
	}
}

func (w workflowExecutionDo) Last() (*models.WorkflowExecution, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowExecution), nil
	}
}

func (w workflowExecutionDo) Find() ([]*models.WorkflowExecution, error) {
	result, err := w.DO.Find()
	return result.([]*models.WorkflowExecution), err
}

func (w workflowExecutionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.WorkflowExecution, err error) {
	buf := make([]*models.WorkflowExecution, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w workflowExecutionDo) FindInBatches(result *[]*models.WorkflowExecution, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w workflowExecutionDo) Attrs(attrs ...field.AssignExpr) *workflowExecutionDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w workflowExecutionDo) Assign(attrs ...field.AssignExpr) *workflowExecutionDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w workflowExecutionDo) Joins(field field.RelationField) *workflowExecutionDo {
	return w.withDO(w.DO.Joins(field))
}

func (w workflowExecutionDo) Preload(field field.RelationField) *workflowExecutionDo {
	return w.withDO(w.DO.Preload(field))
}

func (w workflowExecutionDo) FirstOrInit() (*models.WorkflowExecution, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowExecution), nil
	}
}

func (w workflowExecutionDo) FirstOrCreate() (*models.WorkflowExecution, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.WorkflowExecution), nil
	}
}

func (w workflowExecutionDo) FindByPage(offset int, limit int) (result []*models.WorkflowExecution, count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	result, err = w.Offset(offset).Limit(limit).Find()
	return
}

func (w workflowExecutionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w *workflowExecutionDo) withDO(do gen.Dao) *workflowExecutionDo {
	w.DO = *do.(*gen.DO)
	return w
}
