// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"seraph/app/db/models"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newActionExecution(db *gorm.DB) actionExecution {
	_actionExecution := actionExecution{}

	_actionExecution.actionExecutionDo.UseDB(db)
	_actionExecution.actionExecutionDo.UseModel(&models.ActionExecution{})

	tableName := _actionExecution.actionExecutionDo.TableName()
	_actionExecution.ALL = field.NewField(tableName, "*")
	_actionExecution.ID = field.NewString(tableName, "id")
	_actionExecution.Name = field.NewString(tableName, "name")
	_actionExecution.Description = field.NewString(tableName, "description")
	_actionExecution.Tags = field.NewField(tableName, "tags")
	_actionExecution.WorkflowID = field.NewString(tableName, "workflow_id")
	_actionExecution.ProjectID = field.NewString(tableName, "project_id")
	_actionExecution.State = field.NewString(tableName, "state")
	_actionExecution.StateInfo = field.NewString(tableName, "state_info")
	_actionExecution.CreatedAt = field.NewTime(tableName, "created_at")
	_actionExecution.UpdatedAt = field.NewTime(tableName, "updated_at")
	_actionExecution.Deleted = field.NewInt(tableName, "deleted")
	_actionExecution.DeletedAt = field.NewTime(tableName, "deleted_at")
	_actionExecution.WorkflowNamespace = field.NewString(tableName, "workflow_namespace")
	_actionExecution.Scope = field.NewString(tableName, "scope")
	_actionExecution.StartedAt = field.NewTime(tableName, "started_at")
	_actionExecution.FinishedAt = field.NewTime(tableName, "finished_at")
	_actionExecution.RootExecutionID = field.NewString(tableName, "root_execution_id")
	_actionExecution.Spec = field.NewString(tableName, "spec")
	_actionExecution.Inputs = field.NewField(tableName, "inputs")
	_actionExecution.Outputs = field.NewField(tableName, "outputs")
	_actionExecution.TaskExecutionID = field.NewString(tableName, "task_execution_id")
	_actionExecution.LastHeartbeat = field.NewTime(tableName, "last_heartbeat")
	_actionExecution.RuntimeContext = field.NewField(tableName, "runtime_context")
	_actionExecution.WorkflowName = field.NewString(tableName, "workflow_name")

	_actionExecution.fillFieldMap()

	return _actionExecution
}

type actionExecution struct {
	actionExecutionDo actionExecutionDo

	ALL               field.Field
	ID                field.String
	Name              field.String
	Description       field.String
	Tags              field.Field
	WorkflowID        field.String
	ProjectID         field.String
	State             field.String
	StateInfo         field.String
	CreatedAt         field.Time
	UpdatedAt         field.Time
	Deleted           field.Int
	DeletedAt         field.Time
	WorkflowNamespace field.String
	Scope             field.String
	StartedAt         field.Time
	FinishedAt        field.Time
	RootExecutionID   field.String
	Spec              field.String
	Inputs            field.Field
	Outputs           field.Field
	TaskExecutionID   field.String
	LastHeartbeat     field.Time
	RuntimeContext    field.Field
	WorkflowName      field.String

	fieldMap map[string]field.Expr
}

func (a actionExecution) As(alias string) *actionExecution {
	a.actionExecutionDo.DO = *(a.actionExecutionDo.As(alias).(*gen.DO))

	a.ALL = field.NewField(alias, "*")
	a.ID = field.NewString(alias, "id")
	a.Name = field.NewString(alias, "name")
	a.Description = field.NewString(alias, "description")
	a.Tags = field.NewField(alias, "tags")
	a.WorkflowID = field.NewString(alias, "workflow_id")
	a.ProjectID = field.NewString(alias, "project_id")
	a.State = field.NewString(alias, "state")
	a.StateInfo = field.NewString(alias, "state_info")
	a.CreatedAt = field.NewTime(alias, "created_at")
	a.UpdatedAt = field.NewTime(alias, "updated_at")
	a.Deleted = field.NewInt(alias, "deleted")
	a.DeletedAt = field.NewTime(alias, "deleted_at")
	a.WorkflowNamespace = field.NewString(alias, "workflow_namespace")
	a.Scope = field.NewString(alias, "scope")
	a.StartedAt = field.NewTime(alias, "started_at")
	a.FinishedAt = field.NewTime(alias, "finished_at")
	a.RootExecutionID = field.NewString(alias, "root_execution_id")
	a.Spec = field.NewString(alias, "spec")
	a.Inputs = field.NewField(alias, "inputs")
	a.Outputs = field.NewField(alias, "outputs")
	a.TaskExecutionID = field.NewString(alias, "task_execution_id")
	a.LastHeartbeat = field.NewTime(alias, "last_heartbeat")
	a.RuntimeContext = field.NewField(alias, "runtime_context")
	a.WorkflowName = field.NewString(alias, "workflow_name")

	a.fillFieldMap()

	return &a
}

func (a *actionExecution) WithContext(ctx context.Context) *actionExecutionDo {
	return a.actionExecutionDo.WithContext(ctx)
}

func (a actionExecution) TableName() string { return a.actionExecutionDo.TableName() }

func (a *actionExecution) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	return _f.(field.OrderExpr), ok
}

func (a *actionExecution) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 24)
	a.fieldMap["id"] = a.ID
	a.fieldMap["name"] = a.Name
	a.fieldMap["description"] = a.Description
	a.fieldMap["tags"] = a.Tags
	a.fieldMap["workflow_id"] = a.WorkflowID
	a.fieldMap["project_id"] = a.ProjectID
	a.fieldMap["state"] = a.State
	a.fieldMap["state_info"] = a.StateInfo
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["deleted"] = a.Deleted
	a.fieldMap["deleted_at"] = a.DeletedAt
	a.fieldMap["workflow_namespace"] = a.WorkflowNamespace
	a.fieldMap["scope"] = a.Scope
	a.fieldMap["started_at"] = a.StartedAt
	a.fieldMap["finished_at"] = a.FinishedAt
	a.fieldMap["root_execution_id"] = a.RootExecutionID
	a.fieldMap["spec"] = a.Spec
	a.fieldMap["inputs"] = a.Inputs
	a.fieldMap["outputs"] = a.Outputs
	a.fieldMap["task_execution_id"] = a.TaskExecutionID
	a.fieldMap["last_heartbeat"] = a.LastHeartbeat
	a.fieldMap["runtime_context"] = a.RuntimeContext
	a.fieldMap["workflow_name"] = a.WorkflowName
}

func (a actionExecution) clone(db *gorm.DB) actionExecution {
	a.actionExecutionDo.ReplaceDB(db)
	return a
}

type actionExecutionDo struct{ gen.DO }

func (a actionExecutionDo) Debug() *actionExecutionDo {
	return a.withDO(a.DO.Debug())
}

func (a actionExecutionDo) WithContext(ctx context.Context) *actionExecutionDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a actionExecutionDo) Clauses(conds ...clause.Expression) *actionExecutionDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a actionExecutionDo) Not(conds ...gen.Condition) *actionExecutionDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a actionExecutionDo) Or(conds ...gen.Condition) *actionExecutionDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a actionExecutionDo) Select(conds ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a actionExecutionDo) Where(conds ...gen.Condition) *actionExecutionDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a actionExecutionDo) Order(conds ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a actionExecutionDo) Distinct(cols ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a actionExecutionDo) Omit(cols ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a actionExecutionDo) Join(table schema.Tabler, on ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a actionExecutionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a actionExecutionDo) RightJoin(table schema.Tabler, on ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a actionExecutionDo) Group(cols ...field.Expr) *actionExecutionDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a actionExecutionDo) Having(conds ...gen.Condition) *actionExecutionDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a actionExecutionDo) Limit(limit int) *actionExecutionDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a actionExecutionDo) Offset(offset int) *actionExecutionDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a actionExecutionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *actionExecutionDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a actionExecutionDo) Unscoped() *actionExecutionDo {
	return a.withDO(a.DO.Unscoped())
}

func (a actionExecutionDo) Create(values ...*models.ActionExecution) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a actionExecutionDo) CreateInBatches(values []*models.ActionExecution, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a actionExecutionDo) Save(values ...*models.ActionExecution) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a actionExecutionDo) First() (*models.ActionExecution, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.ActionExecution), nil
	}
}

func (a actionExecutionDo) Take() (*models.ActionExecution, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.ActionExecution), nil
	}
}

func (a actionExecutionDo) Last() (*models.ActionExecution, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.ActionExecution), nil
	}
}

func (a actionExecutionDo) Find() ([]*models.ActionExecution, error) {
	result, err := a.DO.Find()
	return result.([]*models.ActionExecution), err
}

func (a actionExecutionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ActionExecution, err error) {
	buf := make([]*models.ActionExecution, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a actionExecutionDo) FindInBatches(result *[]*models.ActionExecution, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a actionExecutionDo) Attrs(attrs ...field.AssignExpr) *actionExecutionDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a actionExecutionDo) Assign(attrs ...field.AssignExpr) *actionExecutionDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a actionExecutionDo) Joins(field field.RelationField) *actionExecutionDo {
	return a.withDO(a.DO.Joins(field))
}

func (a actionExecutionDo) Preload(field field.RelationField) *actionExecutionDo {
	return a.withDO(a.DO.Preload(field))
}

func (a actionExecutionDo) FirstOrInit() (*models.ActionExecution, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.ActionExecution), nil
	}
}

func (a actionExecutionDo) FirstOrCreate() (*models.ActionExecution, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.ActionExecution), nil
	}
}

func (a actionExecutionDo) FindByPage(offset int, limit int) (result []*models.ActionExecution, count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	result, err = a.Offset(offset).Limit(limit).Find()
	return
}

func (a actionExecutionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a *actionExecutionDo) withDO(do gen.Dao) *actionExecutionDo {
	a.DO = *do.(*gen.DO)
	return a
}
